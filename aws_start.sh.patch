--- startup/aws_start.sh	2024-06-11 00:28:20.565500271 -0700
+++ startup/aws_start.sh	2024-06-11 00:32:41.155649058 -0700
@@ -30,6 +30,44 @@
   fi
 }
 
+get_resources_file() {
+  local rfile="${DIR}/../local/resources.json"
+  local dfile="${DIR}/../local/resources.json.default"
+  if [ -f "${rfile}" ]; then
+    echo "${rfile}"
+  elif [ -f "${dfile}" ]; then
+    echo "${dfile}"
+  else
+    echo ""
+    exit 1
+  fi
+}
+
+find_ec2_gpu_instance_type() {
+  local gpucnt=0
+  local gpumem=0
+  if rfile=$(get_resources_file); then
+    # Parse the number of GPUs and memory per GPU from the resource_manager component in local/resources.json
+    gpucnt=$(jq -r '.components[] | select(.id == "resource_manager") | .args.num_of_gpus' "${rfile}")
+    if [ ${gpucnt} -gt 0 ]; then
+      gpumem=$(jq -r '.components[] | select(.id == "resource_manager") | .args.mem_per_gpu_in_GiB' "${rfile}")
+      if [ ${gpumem} -gt 0 ]; then
+        gpumem=$(( ${gpumem}*1024 ))
+        printf "    finding smallest instance type with $gpucnt GPUs and $gpumem VRAM ... "
+        gpu_types=$(aws ec2 describe-instance-types --region ${REGION} --query 'InstanceTypes[?GpuInfo.Gpus[?Manufacturer==`NVIDIA`]].{InstanceType: InstanceType, GPU: GpuInfo.Gpus[*].{Name: Name, GpuMemoryMiB: MemoryInfo.SizeInMiB, GpuCount: Count}, Architecture: ProcessorInfo.SupportedArchitectures, VCpuCount: VCpuInfo.DefaultVCpus, MemoryMiB: MemoryInfo.SizeInMiB}' --output json)
+        filtered_gpu_types=$(echo ${gpu_types} | jq "[.[] | select(.GPU | any(.GpuCount == ${gpucnt} and .GpuMemoryMiB >= ${gpumem})) | select(.Architecture | index(\"${ARCH}\"))]")
+        smallest_gpu_type=$(echo ${filtered_gpu_types} | jq -r 'min_by(.VCpuCount).InstanceType')        
+        if [ ${smallest_gpu_type} = null ]; then
+          echo "failed finding a GPU instance, EC2_TYPE unchanged."
+        else
+          echo "${smallest_gpu_type}"
+          EC2_TYPE=${smallest_gpu_type}
+        fi
+      fi
+    fi
+  fi
+}
+
 # parse arguments
 while [[ $# -gt 0 ]]
 do
@@ -58,7 +96,9 @@
 SECURITY_GROUP=nvflare_client_sg_$RANDOM
 DEST_FOLDER=/var/tmp/cloud
 KEY_PAIR=NVFlareClientKeyPair
-KEY_FILE=${KEY_PAIR}.pem
+KEY_FILE=$(pwd)/${KEY_PAIR}.pem
+ARCH=x86_64
+IMAGE_OWNER="099720109477" # Owner account id=Amazon
 
 echo "This script requires aws (AWS CLI), sshpass, dig and jq.  Now checking if they are installed."
 
@@ -66,34 +106,39 @@
 check_binary sshpass "Please install it first."
 check_binary dig "Please install it first."
 check_binary jq "Please install it first."
+echo "Note: run this command first for a different AWS profile:"
+echo -e "  export AWS_PROFILE=your-profile-name.\n"
 
-if [ -z ${vpc_id+x} ]
-then
+if [ -z ${vpc_id+x} ]; then
     using_default_vpc=true
 else
     using_default_vpc=false
 fi
 
-if [ -z ${image_name+x} ]
-then
+if [ -z ${image_name+x} ]; then
     container=false
 else
     container=true
 fi
 
-if [ $container = true ]
-then
+aws_identity=$(aws sts get-caller-identity)
+if [[ $? -ne 0 ]]; then
+  echo ""
+  exit 1
+fi
+
+REGION=$(aws configure get region 2>/dev/null)                                                                                                                        : "${REGION:=us-west-2}"                                                                                                                                              : "${AWS_DEFAULT_REGION:=$REGION}"                                                                                                                                    : "${AWS_REGION:=$AWS_DEFAULT_REGION}"                                                                                                                              MYREGION=${AWS_REGION}
+
+if [ $container = true ]; then 
   AMI_IMAGE=ami-06b8d5099f3a8d79d
   EC2_TYPE=t2.xlarge
-  REGION=us-west-2
 else
-  AMI_IMAGE=ami-04bad3c587fe60d89
+  AMI_IMAGE=ami-01ed44191042f130f  # 22.04  20.04:ami-063da375c17d500ab 24.04:ami-0833a2b4abf788b34
+  AMI_NAME="ubuntu-*-22.04-amd64-pro-server"
   EC2_TYPE=t2.small
-  REGION=us-west-2
 fi
 
-if [ -z ${config_file+x} ]
-then
+if [ -z ${config_file+x} ]; then 
     useDefault=true
 else
     useDefault=false
@@ -101,34 +146,44 @@
     report_status "$?" "Loading config file"
 fi
 
-if [ $useDefault = true ]
-then
-  while true
-  do
-    prompt AMI_IMAGE "Cloud AMI image, press ENTER to accept default ${AMI_IMAGE}: "
-    prompt EC2_TYPE "Cloud EC2 type, press ENTER to accept default ${EC2_TYPE}: "
-    prompt REGIION "Cloud EC2 region, press ENTER to accept default ${REGION}: "
+
+
+if [ $useDefault = true ]; then 
+  while true; do
+    read -e -i ${REGION} -p "Cloud EC2 region, press ENTER to accept default: " REGION 
+    read -e -i ${AMI_NAME} -p "Cloud AMI image name, press ENTER to accept default (use amd64 or arm64): " AMI_NAME
+    echo "    retrieving AMI ID for ${AMI_NAME}..." 
+    IMAGES=$(aws ec2 describe-images --region ${REGION} --owners ${IMAGE_OWNER} --filters "Name=name,Values=*${AMI_NAME}*" --output json)
+    if [ "${#IMAGES}" -lt 30 ]; then
+      echo -e "No images found, starting over\n"
+      continue
+    fi
+    AMI_IMAGE=$(echo $IMAGES | jq -r '.Images | sort_by(.CreationDate) | last(.[]).ImageId')
+    read -e -i ${AMI_IMAGE} -p "Cloud AMI image id, press ENTER to accept default: " AMI_IMAGE
+    if [[ "$AMI_NAME" == *"arm64"* ]]; then
+      ARCH="arm64"
+    fi
+    if [ ${container} = false ]; then
+      find_ec2_gpu_instance_type
+    fi
+    read -e -i ${EC2_TYPE} -p "Cloud EC2 type, press ENTER to accept default: " EC2_TYPE
     prompt ans "region = ${REGION}, ami image = ${AMI_IMAGE}, EC2 type = ${EC2_TYPE}, OK? (Y/n) "
-    if [[ $ans = "" ]] || [[ $ans =~ ^(y|Y)$ ]]
-    then
+    if [[ $ans = "" ]] || [[ $ans =~ ^(y|Y)$ ]]; then
       break
     fi
   done
 fi
 
-if [ $container = false ]
-then
+if [ $container = false ]; then
   echo "If the client requires additional dependencies, please copy the requirements.txt to ${DIR}."
   prompt ans "Press ENTER when it's done or no additional dependencies. "
 fi
 
 # Check if default VPC exists
-if [ $using_default_vpc == true ]
-then
+if [ $using_default_vpc == true ]; then 
   echo "Checking if default VPC exists"
   found_default_vpc=$(aws ec2 describe-vpcs | jq '.Vpcs[] | select(.IsDefault == true)')
-  if [ -z "${found_default_vpc}" ]
-  then
+  if [ -z "${found_default_vpc}" ]; then
     echo "No default VPC found.  Please create one before running this script with the following command."
     echo "aws ec2 create-default-vpc"
     echo "or specify your own vpc and subnet with --vpc-id and --subnet-id"
@@ -146,46 +201,51 @@
 
 echo "Generating key pair for VM"
 
-aws ec2 delete-key-pair --key-name $KEY_PAIR > /dev/null 2>&1
+aws ec2 delete-key-pair --region $REGION --key-name $KEY_PAIR > /dev/null 2>&1
 rm -rf $KEY_FILE
-aws ec2 create-key-pair --key-name $KEY_PAIR --query 'KeyMaterial' --output text > $KEY_FILE
+aws ec2 create-key-pair --region $REGION --key-name $KEY_PAIR --query 'KeyMaterial' --output text > $KEY_FILE
 report_status "$?" "creating key pair"
 chmod 400 $KEY_FILE
 
 # Generate Security Group
 # Try not reusing existing security group because we have to modify it for our own need.
-if [ $using_default_vpc == true ]
-then
-  sg_id=$(aws ec2 create-security-group --group-name $SECURITY_GROUP --description "NVFlare security group" | jq -r .GroupId)
+if [ $using_default_vpc == true ]; then
+  sg_id=$(aws ec2 create-security-group --region $REGION --group-name $SECURITY_GROUP --description "NVFlare security group" | jq -r .GroupId)
 else
-  sg_id=$(aws ec2 create-security-group --group-name $SECURITY_GROUP --description "NVFlare security group" --vpc-id $vpc_id | jq -r .GroupId)
+  sg_id=$(aws ec2 create-security-group --region $REGION --group-name $SECURITY_GROUP --description "NVFlare security group" --vpc-id $vpc_id | jq -r .GroupId)
 fi
 report_status "$?" "creating security group"
 my_public_ip=$(dig +short myip.opendns.com @resolver1.opendns.com)
-if [ "$?" -eq 0 ] && [[ "$my_public_ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]
-then
-  aws ec2 authorize-security-group-ingress --group-id $sg_id --protocol tcp --port 22 --cidr ${my_public_ip}/32 > /tmp/sec_grp.log
+if [ "$?" -eq 0 ] && [[ "$my_public_ip" =~ ^(([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))\.){3}([1-9]?[0-9]|1[0-9][0-9]|2([0-4][0-9]|5[0-5]))$ ]]; then
+  aws ec2 authorize-security-group-ingress --region $REGION --group-id $sg_id --protocol tcp --port 22 --cidr ${my_public_ip}/32 > /tmp/sec_grp.log
 else
   echo "getting my public IP failed, please manually configure the inbound rule to limit SSH access"
-  aws ec2 authorize-security-group-ingress --group-id $sg_id --protocol tcp --port 22 --cidr 0.0.0.0/0 > /tmp/sec_grp.log
+  aws ec2 authorize-security-group-ingress --region $REGION --group-id $sg_id --protocol tcp --port 22 --cidr 0.0.0.0/0 > /tmp/sec_grp.log
 fi
 report_status "$?" "creating security group rules"
 
 # Start provisioning
 
-echo "Creating VM at region $REGION, may take a few minutes."
+echo "Creating VM at region $REGION, this may take a few minutes ... "
 
-if [ $using_default_vpc == true ]
-then
-  aws ec2 run-instances --region $REGION --image-id $AMI_IMAGE --count 1 --instance-type $EC2_TYPE --key-name $KEY_PAIR --security-group-ids $sg_id > vm_create.json
+ ami_info=$(aws ec2 describe-images --region $REGION --image-ids $AMI_IMAGE --output json)
+ amidevice=$(echo $ami_info | jq -r '.Images[0].BlockDeviceMappings[0].DeviceName')
+ block_device_mappings=$(echo $ami_info | jq -r '.Images[0].BlockDeviceMappings')
+ original_size=$(echo $block_device_mappings | jq -r '.[0].Ebs.VolumeSize')
+ original_volume_type=$(echo $block_device_mappings | jq -r '.[0].Ebs.VolumeType')
+ new_size=$((original_size + 8))
+ bdmap='[{"DeviceName":"'${amidevice}'","Ebs":{"VolumeSize":'${new_size}',"VolumeType":"'${original_volume_type}'","DeleteOnTermination":true}}]'
+
+if [ $using_default_vpc == true ]; then
+  aws ec2 run-instances --region $REGION --image-id $AMI_IMAGE --count 1 --instance-type $EC2_TYPE --key-name $KEY_PAIR --security-group-ids $sg_id --block-device-mappings $bdmap > vm_create.json
 else
-  aws ec2 run-instances --region $REGION --image-id $AMI_IMAGE --count 1 --instance-type $EC2_TYPE --key-name $KEY_PAIR --security-group-ids $sg_id --subnet-id $subnet_id > vm_create.json
+  aws ec2 run-instances --region $REGION --image-id $AMI_IMAGE --count 1 --instance-type $EC2_TYPE --key-name $KEY_PAIR --security-group-ids $sg_id --block-device-mappings $bdmap --subnet-id $subnet_id > vm_create.json
 fi
 report_status "$?" "creating VM"
 instance_id=$(jq -r .Instances[0].InstanceId vm_create.json)
 
-aws ec2 wait instance-status-ok --instance-ids $instance_id
-aws ec2 describe-instances --instance-ids $instance_id > vm_result.json
+aws ec2 wait instance-status-ok --region $REGION --instance-ids $instance_id
+aws ec2 describe-instances --region $REGION --instance-ids $instance_id > vm_result.json
 
 IP_ADDRESS=$(jq -r .Reservations[0].Instances[0].PublicIpAddress vm_result.json)
 
@@ -197,9 +257,10 @@
 echo "Destination folder is ${DEST}"
 scp -q -i $KEY_FILE -r -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $PWD $DEST
 report_status "$?" "copying startup kits to VM"
+echo "login to instance:"
+echo "  ssh -i ${KEY_FILE} ubuntu@${IP_ADDRESS}"
 
-if [ $container = true ]
-then
+if [ $container = true ]; then
   echo "Launching container with docker option ${DOCKER_OPTION}."
   ssh -f -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} \
   "docker run -d -v ${DEST_FOLDER}:${DEST_FOLDER} --network host ${DOCKER_OPTION} ${image_name} \
@@ -207,15 +268,24 @@
   -s fed_client.json --set uid=AWS-T4 secure_train=true config_folder=config org=Test \" " > /tmp/nvflare.log 2>&1 
   report_status "$?" "launching container"
 else
-  echo "Installing packages in $VM_NAME, may take a few minutes."
+  echo "Installing os packages with apt in $VM_NAME, this may take a few minutes ... "
+  ssh -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} \
+  " sudo apt update && \
+  sudo DEBIAN_FRONTEND=noninteractive apt install -y gcc python3-dev && \
+  if lspci | grep -i nvidia; then sudo DEBIAN_FRONTEND=noninteractive apt install -y nvidia-driver-535-server; fi && \
+  if lspci | grep -i nvidia; then sudo modprobe nvidia; fi && sleep 10 && \
+  exit" > /tmp/nvflare.log 2>&1
+  echo "Installing user space packages in $VM_NAME, this may take a few minutes ... "
   ssh -f -i $KEY_FILE -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${DEST_SITE} \
-  "pwd && wget -q https://bootstrap.pypa.io/get-pip.py && \
-  python3 get-pip.py && python3 -m pip install nvflare && \
+  " echo 'export PATH=~/.local/bin:\$PATH' >> ~/.bashrc && \
+  export PATH=/home/ubuntu/.local/bin:\$PATH && \
+  pwd && wget -q https://bootstrap.pypa.io/get-pip.py && \
+  python3 get-pip.py --break-system-packages && python3 -m pip install --break-system-packages nvflare && \
   touch ${DEST_FOLDER}/startup/requirements.txt && \
-  python3 -m pip install -r ${DEST_FOLDER}/startup/requirements.txt && \
+  python3 -m pip install --break-system-packages --no-cache-dir -r ${DEST_FOLDER}/startup/requirements.txt && \
+  (crontab -l 2>/dev/null; echo '@reboot  /var/tmp/cloud/startup/start.sh >> /var/tmp/nvflare-client-start.log 2>&1') | crontab && \
   nohup ${DEST_FOLDER}/startup/start.sh && sleep 20 && \
-  exit" > /tmp/nvflare.log 2>&1 
-
+  exit" >> /tmp/nvflare.log 2>&1 
   report_status "$?" "installing packages"
 fi
 
@@ -225,3 +295,7 @@
 echo "Other resources provisioned"
 echo "security group: ${SECURITY_GROUP}"
 echo "key pair: ${KEY_PAIR}"
+echo "review install progress:"
+echo "  tail -f /tmp/nvflare.log"
+echo "login to instance:"
+echo "  ssh -i ${KEY_FILE} ubuntu@${IP_ADDRESS}"
